from sqlalchemy import Column, String, Integer, Float, Boolean, JSON
from db import Base


# PipelineRun represents ONE complete execution of a pipeline.

# Each row in this table corresponds to:
# - one call to PipelineRun(...)
# - one full telemetry payload sent by the SDK

class PipelineRun(Base):
    # Name of the database table
    __tablename__ = "runs"
    run_id = Column(String, primary_key=True)   # Unique identifier for the pipeline run. This comes from the SDK (UUID).

    pipeline_name = Column(String, index=True)  # Name of the pipeline that was executed. Indexed because queries often filter by pipeline name.
    context = Column(JSON)              # Arbitrary metadata associated with the run. Stored as JSON to keep it flexible. Example: request_id, user_id, input parameters

    success = Column(Boolean)           # Whether the pipeline completed successfully or not.
    total_duration_ms = Column(Float)   # Total execution time of the pipeline in milliseconds.


# Step represents ONE step executed inside a pipeline run.
# Multiple Step rows will exist for a single PipelineRun.

class Step(Base):
    # Name of the database table
    __tablename__ = "steps"
    step_id = Column(String, primary_key=True)   # Unique identifier for the step. Generated by the SDK.

    # Foreign-keyâ€“like reference to the parent run.
    # (Not enforced as a DB Foreign Key to keep schema simple.)
    run_id = Column(String, index=True)

    
    step_name = Column(String)         # Human-readable name of the step. Example: fetch_competitors, filter_by_price
    step_type = Column(String, index=True)   # Logical type of the step. Example: filtering, ranking, generation, selection. Indexed for analytical queries.
    candidates_in = Column(Integer)    # Number of items entering the step.
    candidates_out = Column(Integer)   # Number of items exiting the step.
    filters_applied = Column(JSON)     # Details of filters applied during this step. Stored as JSON to allow flexible structure.
    reasoning = Column(String)         # Optional explanation of why decisions were made, useful for LLM-based steps.
    duration_ms = Column(Float)        # Execution time of the step in milliseconds.
